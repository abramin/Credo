// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outbox.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const countPendingOutboxEntries = `-- name: CountPendingOutboxEntries :one
SELECT COUNT(*) FROM outbox WHERE processed_at IS NULL
`

func (q *Queries) CountPendingOutboxEntries(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingOutboxEntries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteProcessedOutboxEntriesBefore = `-- name: DeleteProcessedOutboxEntriesBefore :execresult
DELETE FROM outbox WHERE processed_at IS NOT NULL AND processed_at < $1
`

func (q *Queries) DeleteProcessedOutboxEntriesBefore(ctx context.Context, processedAt sql.NullTime) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteProcessedOutboxEntriesBefore, processedAt)
}

const insertOutboxEntry = `-- name: InsertOutboxEntry :exec
INSERT INTO outbox (id, aggregate_type, aggregate_id, event_type, payload, created_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type InsertOutboxEntryParams struct {
	ID            uuid.UUID
	AggregateType string
	AggregateID   string
	EventType     string
	Payload       json.RawMessage
	CreatedAt     time.Time
}

func (q *Queries) InsertOutboxEntry(ctx context.Context, arg InsertOutboxEntryParams) error {
	_, err := q.db.ExecContext(ctx, insertOutboxEntry,
		arg.ID,
		arg.AggregateType,
		arg.AggregateID,
		arg.EventType,
		arg.Payload,
		arg.CreatedAt,
	)
	return err
}

const listUnprocessedOutboxEntries = `-- name: ListUnprocessedOutboxEntries :many
SELECT id, aggregate_type, aggregate_id, event_type, payload, created_at, processed_at
FROM outbox
WHERE processed_at IS NULL
ORDER BY created_at ASC
LIMIT $1
FOR UPDATE SKIP LOCKED
`

func (q *Queries) ListUnprocessedOutboxEntries(ctx context.Context, limit int32) ([]Outbox, error) {
	rows, err := q.db.QueryContext(ctx, listUnprocessedOutboxEntries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Outbox
	for rows.Next() {
		var i Outbox
		if err := rows.Scan(
			&i.ID,
			&i.AggregateType,
			&i.AggregateID,
			&i.EventType,
			&i.Payload,
			&i.CreatedAt,
			&i.ProcessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markOutboxEntryProcessed = `-- name: MarkOutboxEntryProcessed :execresult
UPDATE outbox
SET processed_at = $2
WHERE id = $1 AND processed_at IS NULL
`

type MarkOutboxEntryProcessedParams struct {
	ID          uuid.UUID
	ProcessedAt sql.NullTime
}

func (q *Queries) MarkOutboxEntryProcessed(ctx context.Context, arg MarkOutboxEntryProcessedParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, markOutboxEntryProcessed, arg.ID, arg.ProcessedAt)
}
