// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: allowlist.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const deleteAllowlistEntry = `-- name: DeleteAllowlistEntry :exec
DELETE FROM rate_limit_allowlist WHERE entry_type = $1 AND identifier = $2
`

type DeleteAllowlistEntryParams struct {
	EntryType  string
	Identifier string
}

func (q *Queries) DeleteAllowlistEntry(ctx context.Context, arg DeleteAllowlistEntryParams) error {
	_, err := q.db.ExecContext(ctx, deleteAllowlistEntry, arg.EntryType, arg.Identifier)
	return err
}

const deleteExpiredAllowlistEntries = `-- name: DeleteExpiredAllowlistEntries :exec
DELETE FROM rate_limit_allowlist WHERE expires_at IS NOT NULL AND expires_at <= $1
`

func (q *Queries) DeleteExpiredAllowlistEntries(ctx context.Context, expiresAt sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredAllowlistEntries, expiresAt)
	return err
}

const isAllowlisted = `-- name: IsAllowlisted :one
SELECT EXISTS(
    SELECT 1
    FROM rate_limit_allowlist
    WHERE identifier = $1
      AND (expires_at IS NULL OR expires_at > $2)
)
`

type IsAllowlistedParams struct {
	Identifier string
	ExpiresAt  sql.NullTime
}

func (q *Queries) IsAllowlisted(ctx context.Context, arg IsAllowlistedParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isAllowlisted, arg.Identifier, arg.ExpiresAt)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listAllowlistEntries = `-- name: ListAllowlistEntries :many
SELECT id, entry_type, identifier, reason, expires_at, created_at, created_by
FROM rate_limit_allowlist
WHERE expires_at IS NULL OR expires_at > $1
`

func (q *Queries) ListAllowlistEntries(ctx context.Context, expiresAt sql.NullTime) ([]RateLimitAllowlist, error) {
	rows, err := q.db.QueryContext(ctx, listAllowlistEntries, expiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RateLimitAllowlist
	for rows.Next() {
		var i RateLimitAllowlist
		if err := rows.Scan(
			&i.ID,
			&i.EntryType,
			&i.Identifier,
			&i.Reason,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAllowlistEntry = `-- name: UpsertAllowlistEntry :exec
INSERT INTO rate_limit_allowlist (id, entry_type, identifier, reason, expires_at, created_at, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (entry_type, identifier) DO UPDATE SET
    reason = EXCLUDED.reason,
    expires_at = EXCLUDED.expires_at
`

type UpsertAllowlistEntryParams struct {
	ID         string
	EntryType  string
	Identifier string
	Reason     string
	ExpiresAt  sql.NullTime
	CreatedAt  time.Time
	CreatedBy  uuid.UUID
}

func (q *Queries) UpsertAllowlistEntry(ctx context.Context, arg UpsertAllowlistEntryParams) error {
	_, err := q.db.ExecContext(ctx, upsertAllowlistEntry,
		arg.ID,
		arg.EntryType,
		arg.Identifier,
		arg.Reason,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.CreatedBy,
	)
	return err
}
