// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth_lockouts.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const applyHardLock = `-- name: ApplyHardLock :execresult
UPDATE auth_lockouts
SET locked_until = $2
WHERE identifier = $1
  AND daily_failures >= $3
  AND (locked_until IS NULL OR locked_until < NOW())
`

type ApplyHardLockParams struct {
	Identifier    string
	LockedUntil   sql.NullTime
	DailyFailures int32
}

func (q *Queries) ApplyHardLock(ctx context.Context, arg ApplyHardLockParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, applyHardLock, arg.Identifier, arg.LockedUntil, arg.DailyFailures)
}

const deleteAuthLockout = `-- name: DeleteAuthLockout :exec
DELETE FROM auth_lockouts WHERE identifier = $1
`

func (q *Queries) DeleteAuthLockout(ctx context.Context, identifier string) error {
	_, err := q.db.ExecContext(ctx, deleteAuthLockout, identifier)
	return err
}

const getAuthLockout = `-- name: GetAuthLockout :one
SELECT identifier, failure_count, daily_failures, locked_until, last_failure_at, requires_captcha
FROM auth_lockouts
WHERE identifier = $1
`

func (q *Queries) GetAuthLockout(ctx context.Context, identifier string) (AuthLockout, error) {
	row := q.db.QueryRowContext(ctx, getAuthLockout, identifier)
	var i AuthLockout
	err := row.Scan(
		&i.Identifier,
		&i.FailureCount,
		&i.DailyFailures,
		&i.LockedUntil,
		&i.LastFailureAt,
		&i.RequiresCaptcha,
	)
	return i, err
}

const getOrCreateAuthLockout = `-- name: GetOrCreateAuthLockout :one
INSERT INTO auth_lockouts (identifier, failure_count, daily_failures, locked_until, last_failure_at, requires_captcha)
VALUES ($1, 0, 0, NULL, $2, FALSE)
ON CONFLICT (identifier) DO UPDATE SET
    identifier = EXCLUDED.identifier
RETURNING identifier, failure_count, daily_failures, locked_until, last_failure_at, requires_captcha
`

type GetOrCreateAuthLockoutParams struct {
	Identifier    string
	LastFailureAt time.Time
}

func (q *Queries) GetOrCreateAuthLockout(ctx context.Context, arg GetOrCreateAuthLockoutParams) (AuthLockout, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateAuthLockout, arg.Identifier, arg.LastFailureAt)
	var i AuthLockout
	err := row.Scan(
		&i.Identifier,
		&i.FailureCount,
		&i.DailyFailures,
		&i.LockedUntil,
		&i.LastFailureAt,
		&i.RequiresCaptcha,
	)
	return i, err
}

const recordFailureAtomic = `-- name: RecordFailureAtomic :one
INSERT INTO auth_lockouts (identifier, failure_count, daily_failures, locked_until, last_failure_at, requires_captcha)
VALUES ($1, 1, 1, NULL, $2, FALSE)
ON CONFLICT (identifier) DO UPDATE SET
    failure_count = auth_lockouts.failure_count + 1,
    daily_failures = auth_lockouts.daily_failures + 1,
    last_failure_at = $2
RETURNING identifier, failure_count, daily_failures, locked_until, last_failure_at, requires_captcha
`

type RecordFailureAtomicParams struct {
	Identifier    string
	LastFailureAt time.Time
}

func (q *Queries) RecordFailureAtomic(ctx context.Context, arg RecordFailureAtomicParams) (AuthLockout, error) {
	row := q.db.QueryRowContext(ctx, recordFailureAtomic, arg.Identifier, arg.LastFailureAt)
	var i AuthLockout
	err := row.Scan(
		&i.Identifier,
		&i.FailureCount,
		&i.DailyFailures,
		&i.LockedUntil,
		&i.LastFailureAt,
		&i.RequiresCaptcha,
	)
	return i, err
}

const resetDailyFailuresBefore = `-- name: ResetDailyFailuresBefore :exec
UPDATE auth_lockouts SET daily_failures = 0 WHERE last_failure_at < $1
`

func (q *Queries) ResetDailyFailuresBefore(ctx context.Context, lastFailureAt time.Time) error {
	_, err := q.db.ExecContext(ctx, resetDailyFailuresBefore, lastFailureAt)
	return err
}

const resetFailureCountBefore = `-- name: ResetFailureCountBefore :exec
UPDATE auth_lockouts SET failure_count = 0 WHERE last_failure_at < $1
`

func (q *Queries) ResetFailureCountBefore(ctx context.Context, lastFailureAt time.Time) error {
	_, err := q.db.ExecContext(ctx, resetFailureCountBefore, lastFailureAt)
	return err
}

const setRequiresCaptcha = `-- name: SetRequiresCaptcha :execresult
UPDATE auth_lockouts
SET requires_captcha = TRUE
WHERE identifier = $1
  AND requires_captcha = FALSE
  AND daily_failures >= $2
`

type SetRequiresCaptchaParams struct {
	Identifier    string
	DailyFailures int32
}

func (q *Queries) SetRequiresCaptcha(ctx context.Context, arg SetRequiresCaptchaParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, setRequiresCaptcha, arg.Identifier, arg.DailyFailures)
}

const sumDailyFailuresBefore = `-- name: SumDailyFailuresBefore :one
SELECT COALESCE(SUM(daily_failures), 0)::bigint
FROM auth_lockouts
WHERE last_failure_at < $1
`

func (q *Queries) SumDailyFailuresBefore(ctx context.Context, lastFailureAt time.Time) (int64, error) {
	row := q.db.QueryRowContext(ctx, sumDailyFailuresBefore, lastFailureAt)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const sumFailureCountBefore = `-- name: SumFailureCountBefore :one
SELECT COALESCE(SUM(failure_count), 0)::bigint
FROM auth_lockouts
WHERE last_failure_at < $1
`

func (q *Queries) SumFailureCountBefore(ctx context.Context, lastFailureAt time.Time) (int64, error) {
	row := q.db.QueryRowContext(ctx, sumFailureCountBefore, lastFailureAt)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const upsertAuthLockout = `-- name: UpsertAuthLockout :exec
INSERT INTO auth_lockouts (identifier, failure_count, daily_failures, locked_until, last_failure_at, requires_captcha)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (identifier) DO UPDATE SET
    failure_count = EXCLUDED.failure_count,
    daily_failures = EXCLUDED.daily_failures,
    locked_until = EXCLUDED.locked_until,
    last_failure_at = EXCLUDED.last_failure_at,
    requires_captcha = EXCLUDED.requires_captcha
`

type UpsertAuthLockoutParams struct {
	Identifier      string
	FailureCount    int32
	DailyFailures   int32
	LockedUntil     sql.NullTime
	LastFailureAt   time.Time
	RequiresCaptcha bool
}

func (q *Queries) UpsertAuthLockout(ctx context.Context, arg UpsertAuthLockoutParams) error {
	_, err := q.db.ExecContext(ctx, upsertAuthLockout,
		arg.Identifier,
		arg.FailureCount,
		arg.DailyFailures,
		arg.LockedUntil,
		arg.LastFailureAt,
		arg.RequiresCaptcha,
	)
	return err
}
