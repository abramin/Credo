// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rate_limit_events.sql

package sqlc

import (
	"context"
	"time"
)

const deleteRateLimitEventsBefore = `-- name: DeleteRateLimitEventsBefore :exec
DELETE FROM rate_limit_events WHERE key = $1 AND occurred_at < $2
`

type DeleteRateLimitEventsBeforeParams struct {
	Key        string
	OccurredAt time.Time
}

func (q *Queries) DeleteRateLimitEventsBefore(ctx context.Context, arg DeleteRateLimitEventsBeforeParams) error {
	_, err := q.db.ExecContext(ctx, deleteRateLimitEventsBefore, arg.Key, arg.OccurredAt)
	return err
}

const deleteRateLimitEventsByKey = `-- name: DeleteRateLimitEventsByKey :exec
DELETE FROM rate_limit_events WHERE key = $1
`

func (q *Queries) DeleteRateLimitEventsByKey(ctx context.Context, key string) error {
	_, err := q.db.ExecContext(ctx, deleteRateLimitEventsByKey, key)
	return err
}

const getLatestRateLimitWindowSeconds = `-- name: GetLatestRateLimitWindowSeconds :one
SELECT window_seconds
FROM rate_limit_events
WHERE key = $1
ORDER BY occurred_at DESC
LIMIT 1
`

func (q *Queries) GetLatestRateLimitWindowSeconds(ctx context.Context, key string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getLatestRateLimitWindowSeconds, key)
	var window_seconds int32
	err := row.Scan(&window_seconds)
	return window_seconds, err
}

const insertRateLimitEvent = `-- name: InsertRateLimitEvent :exec
INSERT INTO rate_limit_events (key, occurred_at, cost, window_seconds)
VALUES ($1, $2, $3, $4)
`

type InsertRateLimitEventParams struct {
	Key           string
	OccurredAt    time.Time
	Cost          int32
	WindowSeconds int32
}

func (q *Queries) InsertRateLimitEvent(ctx context.Context, arg InsertRateLimitEventParams) error {
	_, err := q.db.ExecContext(ctx, insertRateLimitEvent,
		arg.Key,
		arg.OccurredAt,
		arg.Cost,
		arg.WindowSeconds,
	)
	return err
}

const lockRateLimitKey = `-- name: LockRateLimitKey :exec
SELECT pg_advisory_xact_lock(hashtext($1)::bigint)
`

func (q *Queries) LockRateLimitKey(ctx context.Context, hashtext string) error {
	_, err := q.db.ExecContext(ctx, lockRateLimitKey, hashtext)
	return err
}

const minRateLimitOccurredAt = `-- name: MinRateLimitOccurredAt :one
SELECT MIN(occurred_at) AS occurred_at FROM rate_limit_events WHERE key = $1
`

func (q *Queries) MinRateLimitOccurredAt(ctx context.Context, key string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, minRateLimitOccurredAt, key)
	var occurred_at interface{}
	err := row.Scan(&occurred_at)
	return occurred_at, err
}

const sumRateLimitCost = `-- name: SumRateLimitCost :one
SELECT COALESCE(SUM(cost), 0)::bigint FROM rate_limit_events WHERE key = $1
`

func (q *Queries) SumRateLimitCost(ctx context.Context, key string) (int64, error) {
	row := q.db.QueryRowContext(ctx, sumRateLimitCost, key)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const sumRateLimitCostSince = `-- name: SumRateLimitCostSince :one
SELECT COALESCE(SUM(cost), 0)::bigint
FROM rate_limit_events
WHERE key = $1 AND occurred_at >= $2
`

type SumRateLimitCostSinceParams struct {
	Key        string
	OccurredAt time.Time
}

func (q *Queries) SumRateLimitCostSince(ctx context.Context, arg SumRateLimitCostSinceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, sumRateLimitCostSince, arg.Key, arg.OccurredAt)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}
